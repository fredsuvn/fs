<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassKit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.runtime.reflect</a> &gt; <span class="el_source">ClassKit.java</span></div><h1>ClassKit.java</h1><pre class="source lang-java linenums">package space.sunqian.common.runtime.reflect;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.RetainedParam;
import space.sunqian.common.Fs;
import space.sunqian.common.base.exception.UnknownPrimitiveTypeException;
import space.sunqian.common.base.system.JvmKit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Iterator;

/**
 * Utilities for {@link Class}.
 *
 * @author sunqian
 */
public class ClassKit {

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found, it will use {@link Class#getDeclaredField(String)} to try
     * again.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L37">        return getField(cls, name, true);</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found and the {@code searchDeclared} is {@code true}, it will use
     * {@link Class#getDeclaredField(String)} to try again.
     *
     * @param cls            the given class
     * @param name           the specified field name
     * @param searchDeclared specifies whether searches declared fields
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name, boolean searchDeclared) {
        try {
<span class="fc" id="L52">            return cls.getField(name);</span>
<span class="fc" id="L53">        } catch (NoSuchFieldException e) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L56">                    return cls.getDeclaredField(name);</span>
<span class="fc" id="L57">                } catch (NoSuchFieldException ex) {</span>
<span class="fc" id="L58">                    return null;</span>
                }
            }
        }
<span class="fc" id="L62">        return null;</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getField(String)}. If the field is not found, then this method will use
     * {@link Class#getDeclaredField(String)} to search again. If the field is still not found, then this method will
     * traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredField(String)}.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field searchField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L78">        Field field = getField(cls, name);</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (field != null) {</span>
<span class="fc" id="L80">            return field;</span>
        }
<span class="fc" id="L82">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L84">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L85">            @Nullable Field nextField = searchField(next, name);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if (nextField != null) {</span>
<span class="fc" id="L87">                return nextField;</span>
            }
<span class="fc" id="L89">        }</span>
<span class="fc" id="L90">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found, it will use
     * {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L108">        return getMethod(cls, name, parameterTypes, true);</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared methods
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L129">            return cls.getMethod(name, parameterTypes);</span>
<span class="fc" id="L130">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L133">                    return cls.getDeclaredMethod(name, parameterTypes);</span>
<span class="fc" id="L134">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L135">                    return null;</span>
                }
            }
        }
<span class="fc" id="L139">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getMethod(String, Class[])}. If the method is not found, then this method
     * will use {@link Class#getDeclaredMethod(String, Class[])} to search again. If the method is still not found, then
     * this method will traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredMethod(String, Class[])}.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method searchMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L160">        Method method = getMethod(cls, name, parameterTypes);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L162">            return method;</span>
        }
<span class="fc" id="L164">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L166">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L167">            @Nullable Method nextMethod = searchMethod(next, name, parameterTypes);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (nextMethod != null) {</span>
<span class="fc" id="L169">                return nextMethod;</span>
            }
<span class="fc" id="L171">        }</span>
<span class="fc" id="L172">        return null;</span>
    }

    private static @Nonnull Iterator&lt;Class&lt;?&gt;&gt; toSupertypesAndInterfaces(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L176">        return new Iterator&lt;Class&lt;?&gt;&gt;() {</span>

<span class="fc" id="L178">            private int index = -1;</span>
            private Class&lt;?&gt; @Nullable [] interfaces;
<span class="fc" id="L180">            private @Nullable Class&lt;?&gt; next = getNext();</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L184" title="All 2 branches covered.">                return next != null;</span>
            }

            @Override
            public Class&lt;?&gt; next() {
<span class="fc" id="L189">                Class&lt;?&gt; result = next;</span>
<span class="fc" id="L190">                next = getNext();</span>
<span class="fc" id="L191">                return result;</span>
            }

            private @Nullable Class&lt;?&gt; getNext() {
<span class="fc bfc" id="L195" title="All 2 branches covered.">                if (index == -1) {</span>
<span class="fc" id="L196">                    index++;</span>
<span class="fc" id="L197">                    Class&lt;?&gt; superclass = cls.getSuperclass();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                    if (superclass != null) {</span>
<span class="fc" id="L199">                        return superclass;</span>
                    }
                }
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (interfaces == null) {</span>
<span class="fc" id="L203">                    interfaces = cls.getInterfaces();</span>
                }
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (index &lt; interfaces.length) {</span>
<span class="fc" id="L206">                    return interfaces[index++];</span>
                }
<span class="fc" id="L208">                return null;</span>
            }
        };
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found, it will use
     * {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L226">        return getConstructor(cls, parameterTypes, true);</span>
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared constructors
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L245">            return cls.getConstructor(parameterTypes);</span>
<span class="fc" id="L246">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L249">                    return cls.getDeclaredConstructor(parameterTypes);</span>
<span class="fc" id="L250">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L251">                    return null;</span>
                }
            }
        }
<span class="fc" id="L255">        return null;</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className) {
<span class="fc" id="L269">        return newInstance(className, null);</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc" id="L284">        @Nullable Class&lt;?&gt; cls = classForName(className, loader);</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (cls == null) {</span>
<span class="fc" id="L286">            return null;</span>
        }
<span class="fc" id="L288">        return newInstance(cls);</span>
    }

    /**
     * Returns a new instance for the given class with the empty constructor, may be {@code null} if fails.
     *
     * @param &lt;T&gt;  the instance's type
     * @param type the given class
     * @return a new instance for the given class with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Class&lt;?&gt; type) {
        try {
<span class="fc" id="L300">            Constructor&lt;?&gt; constructor = type.getConstructor();</span>
<span class="fc" id="L301">            return newInstance(constructor);</span>
<span class="fc" id="L302">        } catch (Exception e) {</span>
<span class="fc" id="L303">            return null;</span>
        }
    }

    /**
     * Creates a new instance with the given constructor and arguments, may be {@code null} if fails.
     *
     * @param constructor the given constructor
     * @param args        the given arguments
     * @param &lt;T&gt;         the instance's type
     * @return a new instance with the given constructor and arguments, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Constructor&lt;?&gt; constructor, Object @Nonnull ... args) {
        try {
<span class="fc" id="L317">            return Fs.as(constructor.newInstance(args));</span>
<span class="fc" id="L318">        } catch (Exception e) {</span>
<span class="fc" id="L319">            return null;</span>
        }
    }

    /**
     * Returns the array class whose component type is the specified type, may be {@code null} if fails. Note
     * {@link TypeVariable} and {@link WildcardType} are unsupported.
     *
     * @param componentType the specified component type
     * @return the array class whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable Class&lt;?&gt; arrayClass(@Nonnull Type componentType) {
<span class="fc" id="L331">        return ArrayClassService.INST.arrayClass(componentType);</span>
    }

    /**
     * Returns the array class name whose component type is the specified type, may be {@code null} if fails.
     *
     * @param componentType the specified component type
     * @return the array class name whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable String arrayClassName(@Nonnull Class&lt;?&gt; componentType) {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (componentType.isArray()) {</span>
<span class="fc" id="L342">            return &quot;[&quot; + componentType.getName();</span>
        }
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (componentType.isPrimitive()) {</span>
            // No void[]
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (Fs.equals(componentType, void.class)) {</span>
<span class="fc" id="L347">                return null;</span>
            }
<span class="fc" id="L349">            return &quot;[&quot; + JvmKit.toDescriptor(componentType);</span>
        }
<span class="fc" id="L351">        return &quot;[L&quot; + componentType.getName() + &quot;;&quot;;</span>
    }

    /**
     * Returns the wrapper class if the given class is primitive, else return the given class itself.
     *
     * @param cls the given class
     * @return the wrapper class if the given class is primitive, else return the given class itself
     */
    public static @Nonnull Class&lt;?&gt; wrapperClass(@Nonnull Class&lt;?&gt; cls) {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (!cls.isPrimitive()) {</span>
<span class="fc" id="L362">            return cls;</span>
        }
<span class="fc" id="L364">        return wrapperPrimitive(cls);</span>
    }

    private static Class&lt;?&gt; wrapperPrimitive(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (Fs.equals(cls, boolean.class)) {</span>
<span class="fc" id="L369">            return Boolean.class;</span>
        }
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (Fs.equals(cls, byte.class)) {</span>
<span class="fc" id="L372">            return Byte.class;</span>
        }
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (Fs.equals(cls, short.class)) {</span>
<span class="fc" id="L375">            return Short.class;</span>
        }
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (Fs.equals(cls, char.class)) {</span>
<span class="fc" id="L378">            return Character.class;</span>
        }
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (Fs.equals(cls, int.class)) {</span>
<span class="fc" id="L381">            return Integer.class;</span>
        }
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (Fs.equals(cls, long.class)) {</span>
<span class="fc" id="L384">            return Long.class;</span>
        }
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (Fs.equals(cls, float.class)) {</span>
<span class="fc" id="L387">            return Float.class;</span>
        }
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (Fs.equals(cls, double.class)) {</span>
<span class="fc" id="L390">            return Double.class;</span>
        }
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (Fs.equals(cls, void.class)) {</span>
<span class="fc" id="L393">            return Void.class;</span>
        }
<span class="fc" id="L395">        throw new UnknownPrimitiveTypeException(cls);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader.
     *
     * @param className the given class name
     * @return whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader
     */
    public static boolean classExists(@Nonnull String className) {
<span class="fc" id="L407">        return classExists(className, null);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @return whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader
     */
    public static boolean classExists(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        return classForName(className, loader) != null;</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method is equivalent to
     * {@code classForName(name, null)}.
     *
     * @param name the given name of the class or interface
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     * @see #classForName(String, ClassLoader)
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name) {
<span class="fc" id="L432">        return classForName(name, null);</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method calls {@link Class#forName(String)} if
     * the given class loader is {@code null}, or {@link Class#forName(String, boolean, ClassLoader)} if not.
     *
     * @param name   the given name of the class or interface
     * @param loader the given class loader, may be {@code null}
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name, @Nullable ClassLoader loader) {
        try {
<span class="fc bfc" id="L445" title="All 2 branches covered.">            return loader == null ? Class.forName(name) : Class.forName(name, true, loader);</span>
<span class="fc" id="L446">        } catch (Exception e) {</span>
<span class="fc" id="L447">            return null;</span>
        }
    }

    /**
     * Returns a new {@link BytesClassLoader} instance.
     *
     * @return a new {@link BytesClassLoader} instance
     */
    public static @Nonnull BytesClassLoader newClassLoader() {
<span class="fc" id="L457">        return new BytesClassLoader();</span>
    }

    /**
     * Returns whether the given member is static.
     *
     * @param member the given member
     * @return whether the given member is static
     */
    public static boolean isStatic(@Nonnull Member member) {
<span class="fc" id="L467">        return Modifier.isStatic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is public.
     *
     * @param member the given member
     * @return whether the given member is public
     */
    public static boolean isPublic(@Nonnull Member member) {
<span class="fc" id="L477">        return Modifier.isPublic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is protected.
     *
     * @param member the given member
     * @return whether the given member is protected
     */
    public static boolean isProtected(@Nonnull Member member) {
<span class="fc" id="L487">        return Modifier.isProtected(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is private.
     *
     * @param member the given member
     * @return whether the given member is private
     */
    public static boolean isPrivate(@Nonnull Member member) {
<span class="fc" id="L497">        return Modifier.isPrivate(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is package-private (no modifies).
     *
     * @param member the given member
     * @return whether the given member is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Member member) {
<span class="fc" id="L507">        int mod = member.getModifiers();</span>
<span class="fc bfc" id="L508" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given class is static.
     *
     * @param cls the given class
     * @return whether the given class is static
     */
    public static boolean isStatic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L518">        return Modifier.isStatic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is public.
     *
     * @param cls the given class
     * @return whether the given class is public
     */
    public static boolean isPublic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L528">        return Modifier.isPublic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is protected.
     *
     * @param cls the given class
     * @return whether the given class is protected
     */
    public static boolean isProtected(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L538">        return Modifier.isProtected(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is private.
     *
     * @param cls the given class
     * @return whether the given class is private
     */
    public static boolean isPrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L548">        return Modifier.isPrivate(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is package-private (no modifies).
     *
     * @param cls the given class
     * @return whether the given class is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L558">        int mod = cls.getModifiers();</span>
<span class="fc bfc" id="L559" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private).
     *
     * @param member the given member
     * @return whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private)
     */
    public static boolean isOverridable(@Nonnull Member member) {
<span class="fc" id="L571">        int modifiers = member.getModifiers();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (!isOverridable(modifiers)) {</span>
<span class="fc" id="L573">            return false;</span>
        }
<span class="fc" id="L575">        Class&lt;?&gt; declaringClass = member.getDeclaringClass();</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        return !Modifier.isFinal(declaringClass.getModifiers());</span>
    }

    /**
     * Returns whether the given class can be overridden (no final, no static and no private).
     *
     * @param cls the given class
     * @return whether the given class can be overridden (no final, no static and no private)
     */
    public static boolean isOverridable(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L586">        int modifiers = cls.getModifiers();</span>
<span class="fc" id="L587">        return isOverridable(modifiers);</span>
    }

    private static boolean isOverridable(int mod) {
<span class="fc bfc" id="L591" title="All 2 branches covered.">        return !Modifier.isFinal(mod) &amp;&amp;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">            !Modifier.isStatic(mod) &amp;&amp;</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            !Modifier.isPrivate(mod);</span>
    }

    private ClassKit() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>