<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommonConvertHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.object.convert.handlers</a> &gt; <span class="el_source">CommonConvertHandler.java</span></div><h1>CommonConvertHandler.java</h1><pre class="source lang-java linenums">package space.sunqian.common.object.convert.handlers;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.Fs;
import space.sunqian.common.base.chars.CharsKit;
import space.sunqian.common.base.enums.EnumKit;
import space.sunqian.common.base.number.NumberKit;
import space.sunqian.common.base.option.Option;
import space.sunqian.common.base.date.DateFormatter;
import space.sunqian.common.collect.ArrayKit;
import space.sunqian.common.collect.ArrayOperator;
import space.sunqian.common.collect.CollectKit;
import space.sunqian.common.io.BufferKit;
import space.sunqian.common.io.IOOperator;
import space.sunqian.common.object.convert.ConvertOption;
import space.sunqian.common.object.convert.DataMapper;
import space.sunqian.common.object.convert.ObjectConverter;
import space.sunqian.common.object.data.ObjectBuilder;
import space.sunqian.common.object.data.ObjectBuilderProvider;
import space.sunqian.common.runtime.reflect.ReflectionException;
import space.sunqian.common.runtime.reflect.TypeKit;

import java.io.InputStream;
import java.io.Reader;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZonedDateTime;
import java.time.temporal.TemporalAccessor;
import java.util.AbstractList;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.IntFunction;

/**
 * The common implementation of {@link ObjectConverter.Handler}, also be the default last handler of
 * {@link ObjectConverter#defaultConverter()}.
 * &lt;p&gt;
 * This handler providers the common conversion logic for all types. This is a table showing the conversion logic of
 * this handler for different target types:
 * &lt;table summary=&quot;Conversion Logic&quot;&gt;
 * &lt;tr&gt;
 *     &lt;th&gt;Target&lt;/th&gt;
 *     &lt;th&gt;Source&lt;/th&gt;
 *     &lt;th&gt;Conversion Logic&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td rowspan=&quot;5&quot;&gt;{@link String}, {@link CharSequence}&lt;/td&gt;
 *     &lt;td&gt;{@link InputStream}, {@link ReadableByteChannel}, {@link Reader}, {@link ByteBuffer}, {@code byte[]}&lt;/td&gt;
 *     &lt;td&gt;Using {@link ConvertOption#ioOperator(IOOperator)} and {@link ConvertOption#charset(Charset)}
 *     to decode to string.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@code char[]}&lt;/td&gt;
 *     &lt;td&gt;Using {@link String#String(char[])} to construct to string.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@link BigDecimal}&lt;/td&gt;
 *     &lt;td&gt;Using {@link BigDecimal#toPlainString()}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Date and Time Objects&lt;/td&gt;
 *     &lt;td&gt;Using {@link ConvertOption#timeFormatter(DateFormatter)} to handle.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Others&lt;/td&gt;
 *     &lt;td&gt;Using {@link Object#toString()}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@code byte[]}, {@code char[]}, {@link ByteBuffer}, {@link CharBuffer}&lt;/td&gt;
 *     &lt;td&gt;{@link String}&lt;/td&gt;
 *     &lt;td&gt;Using {@link String#getBytes(Charset)} or {@link String#toCharArray()}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td rowspan=&quot;2&quot;&gt;Numbers&lt;/td&gt;
 *     &lt;td&gt;{@link String}&lt;/td&gt;
 *     &lt;td&gt;Using {@link NumberKit#toNumber(CharSequence, Class)}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Other Numbers&lt;/td&gt;
 *     &lt;td&gt;Using {@link NumberKit#toNumber(Number, Class)}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@code long} and {@link Long}&lt;/td&gt;
 *     &lt;td&gt;Date and Time&lt;/td&gt;
 *     &lt;td&gt;Returns epoch milliseconds of the date or time object.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td rowspan=&quot;2&quot;&gt;{@code boolean} and {@link Boolean}&lt;/td&gt;
 *     &lt;td&gt;Numbers&lt;/td&gt;
 *     &lt;td&gt;{@code false} for {@code 0}, otherwise {@code true}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@link String}&lt;/td&gt;
 *     &lt;td&gt;{@code true} for {@code equalsIgnoreCase(&quot;true&quot;)}, otherwise {@code false}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td rowspan=&quot;2&quot;&gt;Date and Time&lt;/td&gt;
 *     &lt;td&gt;{@link String} and Other Date Time Objects&lt;/td&gt;
 *     &lt;td&gt;Using {@link ConvertOption#timeFormatter(DateFormatter)} to handle.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;{@code long} and {@link Long}&lt;/td&gt;
 *     &lt;td&gt;Treated as an epoch milliseconds, then using {@link ConvertOption#timeFormatter(DateFormatter)} to
 *     handle.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Enums&lt;/td&gt;
 *     &lt;td&gt;Any Objects&lt;/td&gt;
 *     &lt;td&gt;Using {@link EnumKit#findEnum(Class, String)} with the name from {@link Object#toString()}.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Array and Collection Objects&lt;/td&gt;
 *     &lt;td&gt;Array or Iterable Objects&lt;/td&gt;
 *     &lt;td&gt;Array created using reflection. Collection created using its constructor, the supported collection types:
 *     {@link Iterable}, {@link Collection}, {@link List}, {@link AbstractList}, {@link ArrayList}, {@link LinkedList},
 *     {@link CopyOnWriteArrayList}, {@link Set}, {@link LinkedHashSet}, {@link HashSet}, {@link TreeSet},
 *     {@link ConcurrentSkipListSet}. After creating the container, uses the {@code converter} parameter to handle
 *     component types.
 *     &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td&gt;Map and Data Objects&lt;/td&gt;
 *     &lt;td&gt;Any Objects&lt;/td&gt;
 *     &lt;td&gt;Generating data object is based on {@link ConvertOption#builderProvider(ObjectBuilderProvider)} and
 *     {@link ConvertOption#dataMapper(DataMapper)}. Generating map using its constructor, and copying properties
 *     also using {@link ConvertOption#dataMapper(DataMapper)}. The supported map types:
 *     {@link Map}, {@link AbstractMap}, {@link LinkedHashMap}, {@link HashMap}, {@link TreeMap}, {@link ConcurrentMap},
 *     {@link ConcurrentHashMap}, {@link Hashtable}, {@link ConcurrentSkipListMap}.
 *     &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * Note that this handler typically creates new objects and does not perform the same handing as
 * {@link AssignableConvertHandler}.
 */
<span class="fc" id="L167">public class CommonConvertHandler implements ObjectConverter.Handler {</span>

    @Override
    public Object convert(
        @Nullable Object src,
        @Nonnull Type srcType,
        @Nonnull Type target,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) throws Exception {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (src == null) {</span>
<span class="fc" id="L178">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (target instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L181">            Class&lt;?&gt; targetClass = (Class&lt;?&gt;) target;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (targetClass.isEnum()) {</span>
                // to enum:
<span class="fc" id="L184">                String name = src.toString();</span>
<span class="fc" id="L185">                return EnumKit.findEnum(Fs.as(targetClass), name);</span>
            }
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (srcType.equals(String.class)) {</span>
<span class="fc bfc" id="L188" title="All 4 branches covered.">                if (target.equals(byte[].class) || target.equals(ByteBuffer.class)) {</span>
<span class="fc" id="L189">                    Charset charset = Fs.nonnull(</span>
<span class="fc" id="L190">                        Option.findValue(ConvertOption.CHARSET, options),</span>
<span class="fc" id="L191">                        CharsKit.defaultCharset()</span>
                    );
<span class="fc" id="L193">                    byte[] bytes = ((String) src).getBytes(charset);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                    return target.equals(ByteBuffer.class) ? ByteBuffer.wrap(bytes) : bytes;</span>
                }
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (target.equals(char[].class)) {</span>
<span class="fc" id="L197">                    return ((String) src).toCharArray();</span>
                }
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (target.equals(CharBuffer.class)) {</span>
<span class="fc" id="L200">                    return CharBuffer.wrap((String) src);</span>
                }
            }
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (targetClass.isArray()) {</span>
                // to array
<span class="fc" id="L205">                return toArray(src, srcType, targetClass, converter, options);</span>
            }
<span class="fc" id="L207">            ClassHandler classHandler = TargetClasses.get(targetClass);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (classHandler != null) {</span>
<span class="fc" id="L209">                return classHandler.convert(src, srcType, targetClass, converter, options);</span>
            }
<span class="fc" id="L211">            IntFunction&lt;Collection&lt;Object&gt;&gt; collectionFunc = CollectionClasses.get(targetClass);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (collectionFunc != null) {</span>
                // to collection
<span class="fc" id="L214">                return toCollection(</span>
<span class="fc" id="L215">                    src, srcType, collectionFunc, targetClass.getTypeParameters()[0], converter, options</span>
                );
            }
            // to map or data object
<span class="fc" id="L219">            return toDataObject(src, srcType, targetClass, target, converter, options);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        } else if (target instanceof GenericArrayType) {</span>
            // to generic array
<span class="fc" id="L222">            return toArray(src, srcType, (GenericArrayType) target, converter, options);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        } else if (target instanceof ParameterizedType) {</span>
<span class="fc" id="L224">            ParameterizedType paramType = (ParameterizedType) target;</span>
<span class="fc" id="L225">            Class&lt;?&gt; rawTarget = (Class&lt;?&gt;) paramType.getRawType();</span>
<span class="fc" id="L226">            IntFunction&lt;Collection&lt;Object&gt;&gt; collectionFunc = CollectionClasses.get(rawTarget);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (collectionFunc != null) {</span>
                // to collection
<span class="fc" id="L229">                return toCollection(</span>
<span class="fc" id="L230">                    src, srcType, collectionFunc, paramType.getActualTypeArguments()[0], converter, options</span>
                );
            }
            // to map or data object
<span class="fc" id="L234">            return toDataObject(src, srcType, rawTarget, target, converter, options);</span>
        }
<span class="fc" id="L236">        return ObjectConverter.Status.HANDLER_CONTINUE;</span>
    }

    private Object toArray(
        @Nonnull Object src,
        @Nonnull Type srcType,
        @Nonnull Class&lt;?&gt; target,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) {
<span class="fc" id="L246">        return toArray(</span>
            src,
            srcType,
            target,
<span class="fc" id="L250">            target.getComponentType(),</span>
            converter,
            options
        );
    }

    private Object toArray(
        @Nonnull Object src,
        @Nonnull Type srcType,
        @Nonnull GenericArrayType target,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) {
<span class="fc" id="L263">        Class&lt;?&gt; targetClass = Fs.asNonnull(TypeKit.toRuntimeClass(target));</span>
<span class="fc" id="L264">        return toArray(</span>
            src,
            srcType,
            targetClass,
<span class="fc" id="L268">            target.getGenericComponentType(),</span>
            converter,
            options
        );
    }

    private Object toArray(
        @Nonnull Object src,
        @Nonnull Type srcType,
        @Nonnull Class&lt;?&gt; target,
        @Nonnull Type targetComponentType,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) {
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (srcType instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L283">            Class&lt;?&gt; srcClass = (Class&lt;?&gt;) srcType;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (srcClass.isArray()) {</span>
<span class="fc" id="L285">                ArrayOperator srcOperator = ArrayOperator.of(srcClass);</span>
<span class="fc" id="L286">                int size = srcOperator.size(src);</span>
<span class="fc" id="L287">                Object newArray = ArrayKit.newArray(target.getComponentType(), size);</span>
<span class="fc" id="L288">                Class&lt;?&gt; srcComponentType = srcClass.getComponentType();</span>
<span class="fc" id="L289">                ArrayOperator targetOperator = ArrayOperator.of(target);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L291">                    Object srcElement = srcOperator.get(src, i);</span>
<span class="fc" id="L292">                    Object targetElement = converter.convert(srcElement, srcComponentType, targetComponentType, options);</span>
<span class="fc" id="L293">                    targetOperator.set(newArray, i, targetElement);</span>
                }
<span class="fc" id="L295">                return newArray;</span>
            }
        }
<span class="fc" id="L298">        Type srcComponentType = resolveComponentType(srcType);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (srcComponentType == null) {</span>
<span class="fc" id="L300">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
        Collection&lt;?&gt; srcCollection;
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (src instanceof Collection&lt;?&gt;) {</span>
<span class="fc" id="L304">            srcCollection = (Collection&lt;?&gt;) src;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        } else if (src instanceof Iterable&lt;?&gt;) {</span>
<span class="fc" id="L306">            Iterable&lt;?&gt; iter = (Iterable&lt;?&gt;) src;</span>
<span class="fc" id="L307">            srcCollection = CollectKit.addAll(new ArrayList&lt;&gt;(), iter);</span>
<span class="fc" id="L308">        } else {</span>
<span class="fc" id="L309">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
<span class="fc" id="L311">        int size = srcCollection.size();</span>
<span class="fc" id="L312">        Object newArray = ArrayKit.newArray(target.getComponentType(), size);</span>
<span class="fc" id="L313">        ArrayOperator targetOperator = ArrayOperator.of(target);</span>
<span class="fc" id="L314">        int i = 0;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        for (Object srcElement : srcCollection) {</span>
<span class="fc" id="L316">            Object targetElement = converter.convert(srcElement, srcComponentType, targetComponentType, options);</span>
<span class="fc" id="L317">            targetOperator.set(newArray, i++, targetElement);</span>
<span class="fc" id="L318">        }</span>
<span class="fc" id="L319">        return newArray;</span>
    }

    private Object toCollection(
        @Nonnull Object src,
        @Nonnull Type srcType,
        @Nonnull IntFunction&lt;Collection&lt;Object&gt;&gt; collectionFunc,
        @Nonnull Type targetComponentType,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) {
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (srcType instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L331">            Class&lt;?&gt; srcClass = (Class&lt;?&gt;) srcType;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (srcClass.isArray()) {</span>
<span class="fc" id="L333">                ArrayOperator srcOperator = ArrayOperator.of(srcClass);</span>
<span class="fc" id="L334">                int size = srcOperator.size(src);</span>
<span class="fc" id="L335">                Collection&lt;Object&gt; newCollection = collectionFunc.apply(size);</span>
<span class="fc" id="L336">                Class&lt;?&gt; srcComponentType = srcClass.getComponentType();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L338">                    Object srcElement = srcOperator.get(src, i);</span>
<span class="fc" id="L339">                    Object targetElement = converter.convert(srcElement, srcComponentType, targetComponentType, options);</span>
<span class="fc" id="L340">                    newCollection.add(targetElement);</span>
                }
<span class="fc" id="L342">                return newCollection;</span>
            }
        }
<span class="fc" id="L345">        Type srcComponentType = resolveComponentType(srcType);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (srcComponentType == null) {</span>
<span class="fc" id="L347">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
        Collection&lt;?&gt; srcCollection;
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (src instanceof Collection&lt;?&gt;) {</span>
<span class="fc" id="L351">            srcCollection = (Collection&lt;?&gt;) src;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        } else if (src instanceof Iterable&lt;?&gt;) {</span>
<span class="fc" id="L353">            Iterable&lt;?&gt; iter = (Iterable&lt;?&gt;) src;</span>
<span class="fc" id="L354">            srcCollection = CollectKit.addAll(new ArrayList&lt;&gt;(), iter);</span>
<span class="fc" id="L355">        } else {</span>
<span class="fc" id="L356">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
<span class="fc" id="L358">        int size = srcCollection.size();</span>
<span class="fc" id="L359">        Collection&lt;Object&gt; newCollection = collectionFunc.apply(size);</span>
<span class="fc" id="L360">        int i = 0;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for (Object srcElement : srcCollection) {</span>
<span class="fc" id="L362">            Object targetElement = converter.convert(srcElement, srcComponentType, targetComponentType, options);</span>
<span class="fc" id="L363">            newCollection.add(targetElement);</span>
<span class="fc" id="L364">        }</span>
<span class="fc" id="L365">        return newCollection;</span>
    }

    private @Nullable Type resolveComponentType(@Nonnull Type type) {
        try {
<span class="fc" id="L370">            return TypeKit.resolveActualTypeArguments(type, Iterable.class).get(0);</span>
<span class="fc" id="L371">        } catch (ReflectionException e) {</span>
<span class="fc" id="L372">            return null;</span>
        }
    }

    private Object toDataObject(
        @Nonnull Object src,
        @Nonnull Type srcType,
        @Nonnull Class&lt;?&gt; rawTarget,
        @Nonnull Type target,
        @Nonnull ObjectConverter converter,
        @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
    ) throws Exception {
<span class="fc" id="L384">        IntFunction&lt;Object&gt; mapFunc = MapClasses.get(rawTarget);</span>
<span class="fc" id="L385">        DataMapper dataMapper = Fs.nonnull(</span>
<span class="fc" id="L386">            Option.findValue(ConvertOption.DATA_MAPPER, options),</span>
<span class="fc" id="L387">            DataMapper.defaultMapper()</span>
        );
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (mapFunc != null) {</span>
<span class="fc" id="L390">            Object targetObject = mapFunc.apply(0);</span>
<span class="fc" id="L391">            dataMapper.copyProperties(src, srcType, targetObject, target, converter, options);</span>
<span class="fc" id="L392">            return targetObject;</span>
        } else {
<span class="fc" id="L394">            ObjectBuilderProvider builderProvider = Fs.nonnull(</span>
<span class="fc" id="L395">                Option.findValue(ConvertOption.BUILDER_PROVIDER, options),</span>
<span class="fc" id="L396">                ObjectBuilderProvider.defaultProvider()</span>
            );
<span class="fc" id="L398">            ObjectBuilder builder = builderProvider.builder(target);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (builder == null) {</span>
<span class="fc" id="L400">                return ObjectConverter.Status.HANDLER_CONTINUE;</span>
            }
<span class="fc" id="L402">            Object targetBuilder = builder.newBuilder();</span>
<span class="fc" id="L403">            dataMapper.copyProperties(src, srcType, targetBuilder, builder.builderType(), converter, options);</span>
<span class="fc" id="L404">            return builder.build(targetBuilder);</span>
        }
    }

    private static final class CollectionClasses {

        private static final @Nonnull Map&lt;@Nonnull Type, @Nonnull IntFunction&lt;@Nonnull Collection&lt;Object&gt;&gt;&gt; CLASS_MAP;

        static {
<span class="fc" id="L413">            CLASS_MAP = new HashMap&lt;&gt;();</span>
<span class="fc" id="L414">            CLASS_MAP.put(Iterable.class, ArrayList::new);</span>
<span class="fc" id="L415">            CLASS_MAP.put(Collection.class, HashSet::new);</span>
<span class="fc" id="L416">            CLASS_MAP.put(List.class, ArrayList::new);</span>
<span class="fc" id="L417">            CLASS_MAP.put(AbstractList.class, ArrayList::new);</span>
<span class="fc" id="L418">            CLASS_MAP.put(ArrayList.class, ArrayList::new);</span>
<span class="fc" id="L419">            CLASS_MAP.put(LinkedList.class, size -&gt; new LinkedList&lt;&gt;());</span>
<span class="fc" id="L420">            CLASS_MAP.put(CopyOnWriteArrayList.class, size -&gt; new CopyOnWriteArrayList&lt;&gt;());</span>
<span class="fc" id="L421">            CLASS_MAP.put(Set.class, HashSet::new);</span>
<span class="fc" id="L422">            CLASS_MAP.put(LinkedHashSet.class, LinkedHashSet::new);</span>
<span class="fc" id="L423">            CLASS_MAP.put(HashSet.class, HashSet::new);</span>
<span class="fc" id="L424">            CLASS_MAP.put(TreeSet.class, size -&gt; new TreeSet&lt;&gt;());</span>
<span class="fc" id="L425">            CLASS_MAP.put(ConcurrentSkipListSet.class, size -&gt; new ConcurrentSkipListSet&lt;&gt;());</span>
<span class="fc" id="L426">        }</span>

        public static @Nullable IntFunction&lt;@Nonnull Collection&lt;Object&gt;&gt; get(@Nonnull Class&lt;?&gt; target) {
<span class="fc" id="L429">            return CLASS_MAP.get(target);</span>
        }
    }

    private static final class MapClasses {

        private static final @Nonnull Map&lt;@Nonnull Type, @Nonnull IntFunction&lt;@Nonnull Object&gt;&gt; CLASS_MAP;

        static {
<span class="fc" id="L438">            CLASS_MAP = new HashMap&lt;&gt;();</span>
<span class="fc" id="L439">            CLASS_MAP.put(Map.class, HashMap::new);</span>
<span class="fc" id="L440">            CLASS_MAP.put(AbstractMap.class, HashMap::new);</span>
<span class="fc" id="L441">            CLASS_MAP.put(LinkedHashMap.class, LinkedHashMap::new);</span>
<span class="fc" id="L442">            CLASS_MAP.put(HashMap.class, HashMap::new);</span>
<span class="fc" id="L443">            CLASS_MAP.put(TreeMap.class, size -&gt; new TreeMap&lt;&gt;());</span>
<span class="fc" id="L444">            CLASS_MAP.put(ConcurrentMap.class, ConcurrentHashMap::new);</span>
<span class="fc" id="L445">            CLASS_MAP.put(ConcurrentHashMap.class, ConcurrentHashMap::new);</span>
<span class="fc" id="L446">            CLASS_MAP.put(Hashtable.class, Hashtable::new);</span>
<span class="fc" id="L447">            CLASS_MAP.put(ConcurrentSkipListMap.class, size -&gt; new ConcurrentSkipListMap&lt;&gt;());</span>
<span class="fc" id="L448">        }</span>

        public static @Nullable IntFunction&lt;@Nonnull Object&gt; get(@Nonnull Class&lt;?&gt; target) {
<span class="fc" id="L451">            return CLASS_MAP.get(target);</span>
        }
    }

    private interface ClassHandler {
        Object convert(
            @Nonnull Object src,
            @Nonnull Type srcType,
            @Nonnull Class&lt;?&gt; target,
            @Nonnull ObjectConverter converter,
            @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
        ) throws Exception;
    }

    private static final class TargetClasses {

        private static final @Nonnull Map&lt;@Nonnull Type, @Nonnull ClassHandler&gt; HANDLER_MAP;

        static {
<span class="fc" id="L470">            HANDLER_MAP = new HashMap&lt;&gt;();</span>
<span class="fc" id="L471">            HANDLER_MAP.put(String.class, StringClassHandler.INST);</span>
<span class="fc" id="L472">            HANDLER_MAP.put(CharSequence.class, StringClassHandler.INST);</span>
<span class="fc" id="L473">            HANDLER_MAP.put(boolean.class, BooleanClassHandler.INST);</span>
<span class="fc" id="L474">            HANDLER_MAP.put(Boolean.class, BooleanClassHandler.INST);</span>
<span class="fc" id="L475">            HANDLER_MAP.put(byte.class, NumberClassHandler.INST);</span>
<span class="fc" id="L476">            HANDLER_MAP.put(short.class, NumberClassHandler.INST);</span>
<span class="fc" id="L477">            HANDLER_MAP.put(char.class, NumberClassHandler.INST);</span>
<span class="fc" id="L478">            HANDLER_MAP.put(int.class, NumberClassHandler.INST);</span>
<span class="fc" id="L479">            HANDLER_MAP.put(long.class, NumberClassHandler.INST);</span>
<span class="fc" id="L480">            HANDLER_MAP.put(float.class, NumberClassHandler.INST);</span>
<span class="fc" id="L481">            HANDLER_MAP.put(double.class, NumberClassHandler.INST);</span>
<span class="fc" id="L482">            HANDLER_MAP.put(Byte.class, NumberClassHandler.INST);</span>
<span class="fc" id="L483">            HANDLER_MAP.put(Short.class, NumberClassHandler.INST);</span>
<span class="fc" id="L484">            HANDLER_MAP.put(Character.class, NumberClassHandler.INST);</span>
<span class="fc" id="L485">            HANDLER_MAP.put(Integer.class, NumberClassHandler.INST);</span>
<span class="fc" id="L486">            HANDLER_MAP.put(Long.class, NumberClassHandler.INST);</span>
<span class="fc" id="L487">            HANDLER_MAP.put(Float.class, NumberClassHandler.INST);</span>
<span class="fc" id="L488">            HANDLER_MAP.put(Double.class, NumberClassHandler.INST);</span>
<span class="fc" id="L489">            HANDLER_MAP.put(BigInteger.class, NumberClassHandler.INST);</span>
<span class="fc" id="L490">            HANDLER_MAP.put(BigDecimal.class, NumberClassHandler.INST);</span>
<span class="fc" id="L491">            HANDLER_MAP.put(Number.class, NumberClassHandler.INST);</span>
<span class="fc" id="L492">            HANDLER_MAP.put(Date.class, TimeClassHandler.INST);</span>
<span class="fc" id="L493">            HANDLER_MAP.put(Instant.class, TimeClassHandler.INST);</span>
<span class="fc" id="L494">            HANDLER_MAP.put(LocalDateTime.class, TimeClassHandler.INST);</span>
<span class="fc" id="L495">            HANDLER_MAP.put(ZonedDateTime.class, TimeClassHandler.INST);</span>
<span class="fc" id="L496">            HANDLER_MAP.put(OffsetDateTime.class, TimeClassHandler.INST);</span>
<span class="fc" id="L497">            HANDLER_MAP.put(LocalDate.class, TimeClassHandler.INST);</span>
<span class="fc" id="L498">            HANDLER_MAP.put(LocalTime.class, TimeClassHandler.INST);</span>
<span class="fc" id="L499">        }</span>

        public static @Nullable CommonConvertHandler.ClassHandler get(@Nonnull Class&lt;?&gt; target) {
<span class="fc" id="L502">            return HANDLER_MAP.get(target);</span>
        }
    }

<span class="fc" id="L506">    private enum StringClassHandler implements ClassHandler {</span>

<span class="fc" id="L508">        INST;</span>

        @Override
        public Object convert(
            @Nonnull Object src,
            @Nonnull Type srcType,
            @Nonnull Class&lt;?&gt; target,
            @Nonnull ObjectConverter converter,
            @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
        ) throws Exception {
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (src instanceof char[]) {</span>
<span class="fc" id="L519">                return new String((char[]) src);</span>
            }
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (src instanceof BigDecimal) {</span>
<span class="fc" id="L522">                return ((BigDecimal) src).toPlainString();</span>
            }
<span class="fc bfc" id="L524" title="All 2 branches covered.">            if (src instanceof Date) {</span>
<span class="fc" id="L525">                DateFormatter dateFormatter = Fs.nonnull(</span>
<span class="fc" id="L526">                    Option.findValue(ConvertOption.TIME_FORMATTER, options),</span>
<span class="fc" id="L527">                    DateFormatter.defaultFormatter()</span>
                );
<span class="fc" id="L529">                return dateFormatter.format((Date) src);</span>
            }
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (src instanceof TemporalAccessor) {</span>
<span class="fc" id="L532">                DateFormatter dateFormatter = Fs.nonnull(</span>
<span class="fc" id="L533">                    Option.findValue(ConvertOption.TIME_FORMATTER, options),</span>
<span class="fc" id="L534">                    DateFormatter.defaultFormatter()</span>
                );
<span class="fc" id="L536">                return dateFormatter.format((TemporalAccessor) src);</span>
            }
<span class="fc" id="L538">            Charset charset = Fs.nonnull(</span>
<span class="fc" id="L539">                Option.findValue(ConvertOption.CHARSET, options),</span>
<span class="fc" id="L540">                CharsKit.defaultCharset()</span>
            );
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (src instanceof byte[]) {</span>
<span class="fc" id="L543">                return new String((byte[]) src, charset);</span>
            }
<span class="fc bfc" id="L545" title="All 2 branches covered.">            if (src instanceof ByteBuffer) {</span>
<span class="fc" id="L546">                return BufferKit.string((ByteBuffer) src, charset);</span>
            }
<span class="fc" id="L548">            IOOperator ioOperator = Fs.nonnull(</span>
<span class="fc" id="L549">                Option.findValue(ConvertOption.IO_OPERATOR, options),</span>
<span class="fc" id="L550">                IOOperator.defaultOperator()</span>
            );
<span class="fc bfc" id="L552" title="All 2 branches covered.">            if (src instanceof Reader) {</span>
<span class="fc" id="L553">                return ioOperator.string((Reader) src);</span>
            }
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (src instanceof InputStream) {</span>
<span class="fc" id="L556">                return ioOperator.string((InputStream) src, charset);</span>
            }
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (src instanceof ReadableByteChannel) {</span>
<span class="fc" id="L559">                return ioOperator.string((ReadableByteChannel) src, charset);</span>
            }
<span class="fc" id="L561">            return src.toString();</span>
        }
    }

<span class="fc" id="L565">    private enum NumberClassHandler implements ClassHandler {</span>

<span class="fc" id="L567">        INST;</span>

        @Override
        public Object convert(
            @Nonnull Object src,
            @Nonnull Type srcType,
            @Nonnull Class&lt;?&gt; target,
            @Nonnull ObjectConverter converter,
            @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
        ) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (src instanceof String) {</span>
<span class="fc" id="L578">                return NumberKit.toNumber((String) src, target);</span>
            }
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (!(srcType instanceof Class&lt;?&gt;)) {</span>
<span class="fc" id="L581">                return ObjectConverter.Status.HANDLER_CONTINUE;</span>
            }
<span class="fc bfc" id="L583" title="All 4 branches covered.">            if (target.equals(Long.class) || target.equals(long.class)) {</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">                if (srcType.equals(Date.class)) {</span>
<span class="fc" id="L585">                    return ((Date) src).getTime();</span>
                }
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (TemporalAccessor.class.isAssignableFrom((Class&lt;?&gt;) srcType)) {</span>
<span class="fc" id="L588">                    TemporalAccessor ta = (TemporalAccessor) src;</span>
<span class="fc" id="L589">                    DateFormatter dateFormatter = Fs.nonnull(</span>
<span class="fc" id="L590">                        Option.findValue(ConvertOption.TIME_FORMATTER, options),</span>
<span class="fc" id="L591">                        DateFormatter.defaultFormatter()</span>
                    );
<span class="fc" id="L593">                    Date date = dateFormatter.convert(ta, Date.class);</span>
<span class="fc" id="L594">                    return date.getTime();</span>
                }
            }
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (Number.class.isAssignableFrom((Class&lt;?&gt;) srcType)) {</span>
<span class="fc" id="L598">                Number srcNum = (Number) src;</span>
<span class="fc" id="L599">                return NumberKit.toNumber(srcNum, target);</span>
            }
<span class="fc" id="L601">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
    }

<span class="fc" id="L605">    private enum BooleanClassHandler implements ClassHandler {</span>

<span class="fc" id="L607">        INST;</span>

        @Override
        public Object convert(
            @Nonnull Object src,
            @Nonnull Type srcType,
            @Nonnull Class&lt;?&gt; target,
            @Nonnull ObjectConverter converter,
            @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
        ) {
<span class="fc bfc" id="L617" title="All 2 branches covered.">            if (src instanceof Boolean) {</span>
<span class="fc" id="L618">                return src;</span>
            }
<span class="fc bfc" id="L620" title="All 2 branches covered.">            if (src instanceof Number) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                return ((Number) src).intValue() != 0;</span>
            }
<span class="fc bfc" id="L623" title="All 2 branches covered.">            if (src instanceof String) {</span>
<span class="fc" id="L624">                return ((String) src).equalsIgnoreCase(&quot;true&quot;);</span>
            }
<span class="fc" id="L626">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
    }

<span class="fc" id="L630">    private enum TimeClassHandler implements ClassHandler {</span>

<span class="fc" id="L632">        INST;</span>

        @Override
        public Object convert(
            @Nonnull Object src,
            @Nonnull Type srcType,
            @Nonnull Class&lt;?&gt; target,
            @Nonnull ObjectConverter converter,
            @Nonnull Option&lt;?, ?&gt; @Nonnull ... options
        ) {
<span class="fc" id="L642">            DateFormatter dateFormatter = Fs.nonnull(</span>
<span class="fc" id="L643">                Option.findValue(ConvertOption.TIME_FORMATTER, options),</span>
<span class="fc" id="L644">                DateFormatter.defaultFormatter()</span>
            );
<span class="fc bfc" id="L646" title="All 2 branches covered.">            if (srcType.equals(String.class)) {</span>
<span class="fc" id="L647">                return dateFormatter.parse((String) src, target);</span>
            }
<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (srcType.equals(Date.class)) {</span>
<span class="fc" id="L650">                return dateFormatter.convert((Date) src, target);</span>
            }
<span class="fc bfc" id="L652" title="All 4 branches covered.">            if (srcType.equals(long.class) || srcType.equals(Long.class)) {</span>
<span class="fc" id="L653">                Date date = new Date((Long) src);</span>
<span class="fc" id="L654">                return dateFormatter.convert(date, target);</span>
            }
<span class="fc bfc" id="L656" title="All 2 branches covered.">            if (srcType instanceof Class&lt;?&gt;) {</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (TemporalAccessor.class.isAssignableFrom((Class&lt;?&gt;) srcType)) {</span>
<span class="fc" id="L658">                    return dateFormatter.convert((TemporalAccessor) src, target);</span>
                }
            }
<span class="fc" id="L661">            return ObjectConverter.Status.HANDLER_CONTINUE;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>