<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassKit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.runtime.reflect</a> &gt; <span class="el_source">ClassKit.java</span></div><h1>ClassKit.java</h1><pre class="source lang-java linenums">package space.sunqian.common.runtime.reflect;

import space.sunqian.annotations.Immutable;
import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.RetainedParam;
import space.sunqian.common.Fs;
import space.sunqian.common.base.exception.UnknownPrimitiveTypeException;
import space.sunqian.common.base.system.JvmKit;
import space.sunqian.common.collect.ListKit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 * Utilities for {@link Class}.
 *
 * @author sunqian
 */
public class ClassKit {

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found, it will use {@link Class#getDeclaredField(String)} to try
     * again.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L41">        return getField(cls, name, true);</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found and the {@code searchDeclared} is {@code true}, it will use
     * {@link Class#getDeclaredField(String)} to try again.
     *
     * @param cls            the given class
     * @param name           the specified field name
     * @param searchDeclared specifies whether searches declared fields
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name, boolean searchDeclared) {
        try {
<span class="fc" id="L56">            return cls.getField(name);</span>
<span class="fc" id="L57">        } catch (NoSuchFieldException e) {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L60">                    return cls.getDeclaredField(name);</span>
<span class="fc" id="L61">                } catch (NoSuchFieldException ex) {</span>
<span class="fc" id="L62">                    return null;</span>
                }
            }
        }
<span class="fc" id="L66">        return null;</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getField(String)}. If the field is not found, then this method will use
     * {@link Class#getDeclaredField(String)} to search again. If the field is still not found, then this method will
     * traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredField(String)}.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field searchField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L82">        Field field = getField(cls, name);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (field != null) {</span>
<span class="fc" id="L84">            return field;</span>
        }
<span class="fc" id="L86">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L88">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L89">            @Nullable Field nextField = searchField(next, name);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (nextField != null) {</span>
<span class="fc" id="L91">                return nextField;</span>
            }
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found, it will use
     * {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L112">        return getMethod(cls, name, parameterTypes, true);</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared methods
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L133">            return cls.getMethod(name, parameterTypes);</span>
<span class="fc" id="L134">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L137">                    return cls.getDeclaredMethod(name, parameterTypes);</span>
<span class="fc" id="L138">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L139">                    return null;</span>
                }
            }
        }
<span class="fc" id="L143">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getMethod(String, Class[])}. If the method is not found, then this method
     * will use {@link Class#getDeclaredMethod(String, Class[])} to search again. If the method is still not found, then
     * this method will traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredMethod(String, Class[])}.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method searchMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L164">        Method method = getMethod(cls, name, parameterTypes);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L166">            return method;</span>
        }
<span class="fc" id="L168">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L170">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L171">            @Nullable Method nextMethod = searchMethod(next, name, parameterTypes);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (nextMethod != null) {</span>
<span class="fc" id="L173">                return nextMethod;</span>
            }
<span class="fc" id="L175">        }</span>
<span class="fc" id="L176">        return null;</span>
    }

    private static @Nonnull Iterator&lt;Class&lt;?&gt;&gt; toSupertypesAndInterfaces(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L180">        return new Iterator&lt;Class&lt;?&gt;&gt;() {</span>

<span class="fc" id="L182">            private int index = -1;</span>
            private Class&lt;?&gt; @Nullable [] interfaces;
<span class="fc" id="L184">            private @Nullable Class&lt;?&gt; next = getNext();</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L188" title="All 2 branches covered.">                return next != null;</span>
            }

            @Override
            public Class&lt;?&gt; next() {
<span class="fc" id="L193">                Class&lt;?&gt; result = next;</span>
<span class="fc" id="L194">                next = getNext();</span>
<span class="fc" id="L195">                return result;</span>
            }

            private @Nullable Class&lt;?&gt; getNext() {
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (index == -1) {</span>
<span class="fc" id="L200">                    index++;</span>
<span class="fc" id="L201">                    Class&lt;?&gt; superclass = cls.getSuperclass();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                    if (superclass != null) {</span>
<span class="fc" id="L203">                        return superclass;</span>
                    }
                }
<span class="fc bfc" id="L206" title="All 2 branches covered.">                if (interfaces == null) {</span>
<span class="fc" id="L207">                    interfaces = cls.getInterfaces();</span>
                }
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (index &lt; interfaces.length) {</span>
<span class="fc" id="L210">                    return interfaces[index++];</span>
                }
<span class="fc" id="L212">                return null;</span>
            }
        };
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found, it will use
     * {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L230">        return getConstructor(cls, parameterTypes, true);</span>
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared constructors
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L249">            return cls.getConstructor(parameterTypes);</span>
<span class="fc" id="L250">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L253">                    return cls.getDeclaredConstructor(parameterTypes);</span>
<span class="fc" id="L254">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L255">                    return null;</span>
                }
            }
        }
<span class="fc" id="L259">        return null;</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className) {
<span class="fc" id="L273">        return newInstance(className, null);</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc" id="L288">        @Nullable Class&lt;?&gt; cls = classForName(className, loader);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (cls == null) {</span>
<span class="fc" id="L290">            return null;</span>
        }
<span class="fc" id="L292">        return newInstance(cls);</span>
    }

    /**
     * Creates and returns a list of instances for the given class names, in the order of the given names. The class
     * specified by the class name must have an empty constructor for instantiation. If a class instantiation fails, the
     * instance will be skipped and the returned list will be reduced by one accordingly.
     *
     * @param classNames the given class names to be instantiated
     * @param &lt;T&gt;        the instance's type
     * @return a list of instances for the given class names, in the order of the given names
     */
    public static &lt;T&gt; @Nonnull @Immutable List&lt;@Nonnull T&gt; runtimeInstances(
        @Nonnull String @Nonnull ... classNames
    ) {
<span class="fc" id="L307">        Object[] instances = new Object[classNames.length];</span>
<span class="fc" id="L308">        int i = 0;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (String className : classNames) {</span>
<span class="fc" id="L310">            T instance = newInstance(className);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (instance != null) {</span>
<span class="fc" id="L312">                instances[i++] = instance;</span>
            }
        }
<span class="fc bfc" id="L315" title="All 2 branches covered.">        instances = i == classNames.length ? instances : Arrays.copyOf(instances, i);</span>
<span class="fc" id="L316">        return Fs.as(ListKit.list(instances));</span>
    }

    /**
     * Returns a new instance for the given class with the empty constructor, may be {@code null} if fails.
     *
     * @param &lt;T&gt;  the instance's type
     * @param type the given class
     * @return a new instance for the given class with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Class&lt;?&gt; type) {
        try {
<span class="fc" id="L328">            Constructor&lt;?&gt; constructor = type.getConstructor();</span>
<span class="fc" id="L329">            return newInstance(constructor);</span>
<span class="fc" id="L330">        } catch (Exception e) {</span>
<span class="fc" id="L331">            return null;</span>
        }
    }

    /**
     * Creates a new instance with the given constructor and arguments, may be {@code null} if fails.
     *
     * @param constructor the given constructor
     * @param args        the given arguments
     * @param &lt;T&gt;         the instance's type
     * @return a new instance with the given constructor and arguments, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Constructor&lt;?&gt; constructor, Object @Nonnull ... args) {
        try {
<span class="fc" id="L345">            return Fs.as(constructor.newInstance(args));</span>
<span class="fc" id="L346">        } catch (Exception e) {</span>
<span class="fc" id="L347">            return null;</span>
        }
    }

    /**
     * Returns the array class whose component type is the specified type, may be {@code null} if fails. Note
     * {@link TypeVariable} and {@link WildcardType} are unsupported.
     *
     * @param componentType the specified component type
     * @return the array class whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable Class&lt;?&gt; arrayClass(@Nonnull Type componentType) {
<span class="fc" id="L359">        return ArrayClassService.INST.arrayClass(componentType);</span>
    }

    /**
     * Returns the array class name whose component type is the specified type, may be {@code null} if fails.
     *
     * @param componentType the specified component type
     * @return the array class name whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable String arrayClassName(@Nonnull Class&lt;?&gt; componentType) {
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (componentType.isArray()) {</span>
<span class="fc" id="L370">            return &quot;[&quot; + componentType.getName();</span>
        }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (componentType.isPrimitive()) {</span>
            // No void[]
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (Fs.equals(componentType, void.class)) {</span>
<span class="fc" id="L375">                return null;</span>
            }
<span class="fc" id="L377">            return &quot;[&quot; + JvmKit.toDescriptor(componentType);</span>
        }
<span class="fc" id="L379">        return &quot;[L&quot; + componentType.getName() + &quot;;&quot;;</span>
    }

    /**
     * Returns the wrapper class if the given class is primitive, else return the given class itself.
     *
     * @param cls the given class
     * @return the wrapper class if the given class is primitive, else return the given class itself
     */
    public static @Nonnull Class&lt;?&gt; wrapperClass(@Nonnull Class&lt;?&gt; cls) {
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (!cls.isPrimitive()) {</span>
<span class="fc" id="L390">            return cls;</span>
        }
<span class="fc" id="L392">        return wrapperPrimitive(cls);</span>
    }

    private static Class&lt;?&gt; wrapperPrimitive(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (Fs.equals(cls, boolean.class)) {</span>
<span class="fc" id="L397">            return Boolean.class;</span>
        }
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (Fs.equals(cls, byte.class)) {</span>
<span class="fc" id="L400">            return Byte.class;</span>
        }
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (Fs.equals(cls, short.class)) {</span>
<span class="fc" id="L403">            return Short.class;</span>
        }
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (Fs.equals(cls, char.class)) {</span>
<span class="fc" id="L406">            return Character.class;</span>
        }
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (Fs.equals(cls, int.class)) {</span>
<span class="fc" id="L409">            return Integer.class;</span>
        }
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (Fs.equals(cls, long.class)) {</span>
<span class="fc" id="L412">            return Long.class;</span>
        }
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (Fs.equals(cls, float.class)) {</span>
<span class="fc" id="L415">            return Float.class;</span>
        }
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (Fs.equals(cls, double.class)) {</span>
<span class="fc" id="L418">            return Double.class;</span>
        }
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (Fs.equals(cls, void.class)) {</span>
<span class="fc" id="L421">            return Void.class;</span>
        }
<span class="fc" id="L423">        throw new UnknownPrimitiveTypeException(cls);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader.
     *
     * @param className the given class name
     * @return whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader
     */
    public static boolean classExists(@Nonnull String className) {
<span class="fc" id="L435">        return classExists(className, null);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @return whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader
     */
    public static boolean classExists(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc bfc" id="L448" title="All 2 branches covered.">        return classForName(className, loader) != null;</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method is equivalent to
     * {@code classForName(name, null)}.
     *
     * @param name the given name of the class or interface
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     * @see #classForName(String, ClassLoader)
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name) {
<span class="fc" id="L460">        return classForName(name, null);</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method calls {@link Class#forName(String)} if
     * the given class loader is {@code null}, or {@link Class#forName(String, boolean, ClassLoader)} if not.
     *
     * @param name   the given name of the class or interface
     * @param loader the given class loader, may be {@code null}
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name, @Nullable ClassLoader loader) {
        try {
<span class="fc bfc" id="L473" title="All 2 branches covered.">            return loader == null ? Class.forName(name) : Class.forName(name, true, loader);</span>
<span class="fc" id="L474">        } catch (Exception e) {</span>
<span class="fc" id="L475">            return null;</span>
        }
    }

    /**
     * Returns a new {@link BytesClassLoader} instance.
     *
     * @return a new {@link BytesClassLoader} instance
     */
    public static @Nonnull BytesClassLoader newClassLoader() {
<span class="fc" id="L485">        return new BytesClassLoader();</span>
    }

    /**
     * Returns whether the given member is static.
     *
     * @param member the given member
     * @return whether the given member is static
     */
    public static boolean isStatic(@Nonnull Member member) {
<span class="fc" id="L495">        return Modifier.isStatic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is public.
     *
     * @param member the given member
     * @return whether the given member is public
     */
    public static boolean isPublic(@Nonnull Member member) {
<span class="fc" id="L505">        return Modifier.isPublic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is protected.
     *
     * @param member the given member
     * @return whether the given member is protected
     */
    public static boolean isProtected(@Nonnull Member member) {
<span class="fc" id="L515">        return Modifier.isProtected(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is private.
     *
     * @param member the given member
     * @return whether the given member is private
     */
    public static boolean isPrivate(@Nonnull Member member) {
<span class="fc" id="L525">        return Modifier.isPrivate(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is package-private (no modifies).
     *
     * @param member the given member
     * @return whether the given member is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Member member) {
<span class="fc" id="L535">        int mod = member.getModifiers();</span>
<span class="fc bfc" id="L536" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given class is static.
     *
     * @param cls the given class
     * @return whether the given class is static
     */
    public static boolean isStatic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L546">        return Modifier.isStatic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is public.
     *
     * @param cls the given class
     * @return whether the given class is public
     */
    public static boolean isPublic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L556">        return Modifier.isPublic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is protected.
     *
     * @param cls the given class
     * @return whether the given class is protected
     */
    public static boolean isProtected(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L566">        return Modifier.isProtected(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is private.
     *
     * @param cls the given class
     * @return whether the given class is private
     */
    public static boolean isPrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L576">        return Modifier.isPrivate(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is package-private (no modifies).
     *
     * @param cls the given class
     * @return whether the given class is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L586">        int mod = cls.getModifiers();</span>
<span class="fc bfc" id="L587" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private).
     *
     * @param member the given member
     * @return whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private)
     */
    public static boolean isOverridable(@Nonnull Member member) {
<span class="fc" id="L599">        int modifiers = member.getModifiers();</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (!isOverridable(modifiers)) {</span>
<span class="fc" id="L601">            return false;</span>
        }
<span class="fc" id="L603">        Class&lt;?&gt; declaringClass = member.getDeclaringClass();</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        return !Modifier.isFinal(declaringClass.getModifiers());</span>
    }

    /**
     * Returns whether the given class can be overridden (no final, no static and no private).
     *
     * @param cls the given class
     * @return whether the given class can be overridden (no final, no static and no private)
     */
    public static boolean isOverridable(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L614">        int modifiers = cls.getModifiers();</span>
<span class="fc" id="L615">        return isOverridable(modifiers);</span>
    }

    private static boolean isOverridable(int mod) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">        return !Modifier.isFinal(mod) &amp;&amp;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">            !Modifier.isStatic(mod) &amp;&amp;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            !Modifier.isPrivate(mod);</span>
    }

    private ClassKit() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>