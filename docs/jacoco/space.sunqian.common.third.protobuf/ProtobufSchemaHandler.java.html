<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProtobufSchemaHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.third.protobuf</a> &gt; <span class="el_source">ProtobufSchemaHandler.java</span></div><h1>ProtobufSchemaHandler.java</h1><pre class="source lang-java linenums">package space.sunqian.common.third.protobuf;

import com.google.protobuf.Descriptors;
import com.google.protobuf.Message;
import com.google.protobuf.ProtocolStringList;
import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.base.string.StringKit;
import space.sunqian.common.object.data.ObjectProperty;
import space.sunqian.common.object.data.ObjectPropertyBase;
import space.sunqian.common.object.data.ObjectSchemaParser;
import space.sunqian.common.runtime.invoke.Invocable;
import space.sunqian.common.runtime.reflect.TypeKit;
import space.sunqian.common.runtime.reflect.TypeRef;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * {@link ObjectSchemaParser.Handler} implementation for
 * &lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;Protocol Buffers&lt;/a&gt;, can be quickly used through similar
 * codes:
 * &lt;pre&gt;{@code
 * ObjectSchemaParser parser = ObjectSchemaParser
 *     .defaultParser()
 *     .withFirstHandler(new ProtobufSchemaHandler());
 * }&lt;/pre&gt;
 * To use this class, the protobuf package {@code com.google.protobuf} must in the runtime environment.
 * &lt;p&gt;
 * Note:
 * &lt;ul&gt;
 *     &lt;li&gt;
 *         When {@link ProtocolStringList} is used as a property type, it will be mapped to {@code List&lt;String&gt;}, but
 *         the type of the instance returned by {@link ObjectProperty#getValue(Object)} is still
 *         {@link ProtocolStringList};
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *         For a Builder, the properties of {@code repeated} and {@code map} types do not have setter methods, but the
 *         setter (which is am {@link Invocable}) is not null.
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author sunqian
 */
<span class="fc" id="L51">public class ProtobufSchemaHandler implements ObjectSchemaParser.Handler {</span>

<span class="fc" id="L53">    static final class StringListTypeRef extends TypeRef&lt;List&lt;String&gt;&gt; {</span>
<span class="fc" id="L54">        static final @Nonnull StringListTypeRef SINGLETON = new StringListTypeRef();</span>
    }

    @Override
    public boolean parse(@Nonnull ObjectSchemaParser.Context context) throws Exception {
<span class="fc" id="L59">        Class&lt;?&gt; rawType = TypeKit.getRawClass(context.dataType());</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (rawType == null) {</span>
<span class="fc" id="L61">            return true;</span>
        }
        // Check whether it is a protobuf object
<span class="fc" id="L64">        boolean isProtobuf = false;</span>
<span class="fc" id="L65">        boolean isBuilder = false;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (Message.class.isAssignableFrom(rawType)) {</span>
<span class="fc" id="L67">            isProtobuf = true;</span>
        }
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (Message.Builder.class.isAssignableFrom(rawType)) {</span>
<span class="fc" id="L70">            isProtobuf = true;</span>
<span class="fc" id="L71">            isBuilder = true;</span>
        }
<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (!isProtobuf) {</span>
<span class="fc" id="L74">            return true;</span>
        }
<span class="fc" id="L76">        Method getDescriptorMethod = rawType.getMethod(&quot;getDescriptor&quot;);</span>
<span class="fc" id="L77">        Descriptors.Descriptor descriptor = (Descriptors.Descriptor) getDescriptorMethod.invoke(null);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (Descriptors.FieldDescriptor field : descriptor.getFields()) {</span>
<span class="fc" id="L79">            ObjectPropertyBase objectPropertyBase = buildProperty(field, rawType, isBuilder);</span>
<span class="fc" id="L80">            context.propertyBaseMap().put(objectPropertyBase.name(), objectPropertyBase);</span>
<span class="fc" id="L81">        }</span>
<span class="fc" id="L82">        return false;</span>
    }

    private @Nonnull ObjectPropertyBase buildProperty(
        @Nonnull Descriptors.FieldDescriptor field,
        @Nonnull Class&lt;?&gt; rawClass,
        boolean isBuilder
    ) throws Exception {

<span class="fc" id="L91">        String rawName = field.getName();</span>

        // map
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (field.isMapField()) {</span>
<span class="fc" id="L95">            String name = rawName + &quot;Map&quot;;</span>
<span class="fc" id="L96">            Method getterMethod = rawClass.getMethod(&quot;get&quot; + StringKit.capitalize(name));</span>
<span class="fc" id="L97">            Invocable getter = Invocable.of(getterMethod);</span>
<span class="fc" id="L98">            Invocable setter = null;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            if (isBuilder) {</span>
<span class="fc" id="L100">                Method clearMethod = rawClass.getMethod(&quot;clear&quot; + StringKit.capitalize(rawName));</span>
<span class="fc" id="L101">                Method putAllMethod = rawClass.getMethod(&quot;putAll&quot; + StringKit.capitalize(rawName), Map.class);</span>
<span class="fc" id="L102">                setter = new MapSetter(clearMethod, putAllMethod);</span>
            }
<span class="fc" id="L104">            return new PropertyBaseImpl(</span>
                rawName,
<span class="fc" id="L106">                getterMethod.getGenericReturnType(),</span>
                getterMethod,
                null,
                getter,
                setter
            );
        }

        // repeated
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (field.isRepeated()) {</span>
<span class="fc" id="L116">            String name = rawName + &quot;List&quot;;</span>
<span class="fc" id="L117">            Method getterMethod = rawClass.getMethod(&quot;get&quot; + StringKit.capitalize(name));</span>
<span class="fc" id="L118">            Type type = getterMethod.getGenericReturnType();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (Objects.equals(type, ProtocolStringList.class)) {</span>
<span class="fc" id="L120">                type = StringListTypeRef.SINGLETON.type();</span>
            }
<span class="fc" id="L122">            Invocable getter = Invocable.of(getterMethod);</span>
<span class="fc" id="L123">            Invocable setter = null;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            if (isBuilder) {</span>
<span class="fc" id="L125">                Method clearMethod = rawClass.getMethod(&quot;clear&quot; + StringKit.capitalize(rawName));</span>
<span class="fc" id="L126">                Method addAllMethod = rawClass.getMethod(&quot;addAll&quot; + StringKit.capitalize(rawName), Iterable.class);</span>
<span class="fc" id="L127">                setter = new ListSetter(clearMethod, addAllMethod);</span>
            }
<span class="fc" id="L129">            return new PropertyBaseImpl(</span>
                rawName,
                type,
                getterMethod,
                null,
                getter,
                setter
            );
        }

        // Simple object
<span class="fc" id="L140">        Method getterMethod = rawClass.getMethod(&quot;get&quot; + StringKit.capitalize(rawName));</span>
<span class="fc" id="L141">        Type type = getterMethod.getGenericReturnType();</span>
<span class="fc" id="L142">        Invocable getter = Invocable.of(getterMethod);</span>
<span class="fc" id="L143">        Method setterMethod = null;</span>
<span class="fc" id="L144">        Invocable setter = null;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (isBuilder) {</span>
<span class="fc" id="L146">            setterMethod = rawClass.getMethod(&quot;set&quot; + StringKit.capitalize(rawName), TypeKit.getRawClass(type));</span>
<span class="fc" id="L147">            setter = Invocable.of(setterMethod);</span>
        }
<span class="fc" id="L149">        return new PropertyBaseImpl(</span>
            rawName,
            type,
            getterMethod,
            setterMethod,
            getter,
            setter
        );
    }

    private static final class MapSetter implements Invocable {

        private final @Nonnull MethodHandle clearHandle;
        private final @Nonnull MethodHandle putAllHandle;

<span class="fc" id="L164">        private MapSetter(@Nonnull Method clearMethod, @Nonnull Method putAllMethod) throws Exception {</span>
            // setter = (inst, args) -&gt; {
            //     clearMethod.invoke(inst);
            //     return putAllMethod.invoke(inst, args);
            // };
<span class="fc" id="L169">            this.clearHandle = MethodHandles.lookup().unreflect(clearMethod);</span>
<span class="fc" id="L170">            this.putAllHandle = MethodHandles.lookup().unreflect(putAllMethod);</span>
<span class="fc" id="L171">        }</span>

        @Override
        public @Nullable Object invokeChecked(
            @Nullable Object inst, @Nullable Object @Nonnull ... args
        ) throws Throwable {
<span class="fc" id="L177">            clearHandle.invoke(inst);</span>
<span class="fc" id="L178">            putAllHandle.invoke(inst, args[0]);</span>
<span class="fc" id="L179">            return null;</span>
        }
    }

    private static final class ListSetter implements Invocable {

        private final @Nonnull MethodHandle clearHandle;
        private final @Nonnull MethodHandle addAllMethod;

<span class="fc" id="L188">        private ListSetter(@Nonnull Method clearMethod, @Nonnull Method addAllMethod) throws Exception {</span>
            // setter = (inst, args) -&gt; {
            //     clearMethod.invoke(inst);
            //     return addAllMethod.invoke(inst, args);
            // };
<span class="fc" id="L193">            this.clearHandle = MethodHandles.lookup().unreflect(clearMethod);</span>
<span class="fc" id="L194">            this.addAllMethod = MethodHandles.lookup().unreflect(addAllMethod);</span>
<span class="fc" id="L195">        }</span>

        @Override
        public @Nullable Object invokeChecked(
            @Nullable Object inst, @Nullable Object @Nonnull ... args
        ) throws Throwable {
<span class="fc" id="L201">            clearHandle.invoke(inst);</span>
<span class="fc" id="L202">            addAllMethod.invoke(inst, args[0]);</span>
<span class="fc" id="L203">            return null;</span>
        }
    }

    private static final class PropertyBaseImpl implements ObjectPropertyBase {

        private final @Nonnull String name;
        private final @Nonnull Type type;
        private final @Nullable Method getterMethod;
        private final @Nullable Method setterMethod;
        private final @Nonnull Invocable getter;
        private final @Nullable Invocable setter;

        private PropertyBaseImpl(
            @Nonnull String name,
            @Nonnull Type type,
            @Nullable Method getterMethod,
            @Nullable Method setterMethod,
            @Nonnull Invocable getter,
            @Nullable Invocable setter
<span class="fc" id="L223">        ) {</span>
<span class="fc" id="L224">            this.name = name;</span>
<span class="fc" id="L225">            this.type = type;</span>
<span class="fc" id="L226">            this.getterMethod = getterMethod;</span>
<span class="fc" id="L227">            this.setterMethod = setterMethod;</span>
<span class="fc" id="L228">            this.getter = getter;</span>
<span class="fc" id="L229">            this.setter = setter;</span>
<span class="fc" id="L230">        }</span>

        @Override
        public @Nonnull String name() {
<span class="fc" id="L234">            return name;</span>
        }

        @Override
        public @Nonnull Type type() {
<span class="fc" id="L239">            return type;</span>
        }

        @Override
        public @Nullable Method getterMethod() {
<span class="fc" id="L244">            return getterMethod;</span>
        }

        @Override
        public @Nullable Method setterMethod() {
<span class="fc" id="L249">            return setterMethod;</span>
        }

        @Override
        public @Nullable Field field() {
<span class="fc" id="L254">            return null;</span>
        }

        @Override
        public @Nonnull Invocable getter() {
<span class="fc" id="L259">            return getter;</span>
        }

        @Override
        public @Nullable Invocable setter() {
<span class="fc" id="L264">            return setter;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>