// package xyz.sunqian.common.io;
//
// import xyz.sunqian.annotations.Nonnull;
// import xyz.sunqian.annotations.Nullable;
// import xyz.sunqian.common.base.JieCoding;
// import xyz.sunqian.common.base.bytes.JieBytes;
// import xyz.sunqian.common.base.chars.JieChars;
// import xyz.sunqian.common.collect.JieCollect;
//
// import java.io.IOException;
// import java.io.InputStream;
// import java.io.OutputStream;
// import java.nio.ByteBuffer;
// import java.nio.channels.WritableByteChannel;
// import java.util.ArrayList;
// import java.util.Collection;
// import java.util.List;
// import java.util.function.Function;
//
// import static xyz.sunqian.common.base.JieCheck.checkOffsetLength;
//
// final class ByteEncoderImpl implements ByteEncoder {
//
//     private static final @Nonnull ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
//
//     private final @Nonnull Object source;
//     private int readBlockSize = IOKit.bufferSize();
//     private long readLimit = -1;
//     private @Nullable List<Handler> handlers;
//
//     // initials after starting process
//     private @Nullable ByteReader sourceReader;
//     private @Nullable ByteEncoder.Handler oneEncoder;
//
//     ByteEncoderImpl(InputStream src) {
//         this.source = src;
//     }
//
//     ByteEncoderImpl(byte[] src, int off, int len) {
//         this.source = ByteReader.from(src, off, len);
//     }
//
//     ByteEncoderImpl(ByteBuffer src) {
//         this.source = ByteReader.from(src);
//     }
//
//     ByteEncoderImpl(ByteReader src) {
//         this.source = src;
//     }
//
//     // private ByteReader getSourceReader() {
//     //     if (sourceReader == null) {
//     //         sourceReader = toByteReader(getSource());
//     //     }
//     //     return sourceReader;
//     // }
//
//     // private Handler getEncoder() {
//     //     if (oneEncoder == null) {
//     //         oneEncoder = toOneEncoder(handlers);
//     //     }
//     //     return oneEncoder;
//     // }
//
//     @Override
//     public ByteEncoder readLimit(long readLimit) throws IllegalArgumentException {
//         IOChecker.checkReadLimit(readLimit);
//         this.readLimit = readLimit;
//         return this;
//     }
//
//     @Override
//     public ByteEncoder readBlockSize(int readBlockSize) throws IllegalArgumentException {
//         IOChecker.checkReadBlockSize(readBlockSize);
//         this.readBlockSize = readBlockSize;
//         return this;
//     }
//
//     @Override
//     public ByteEncoder handler(Handler handler) {
//         if (handlers == null) {
//             handlers = new ArrayList<>();
//         }
//         handlers.add(handler);
//         return this;
//     }
//
//     @Override
//     public long encode() throws IORuntimeException {
//         try {
//             return doEncode(source, null, 0);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public long encodeTo(@Nonnull OutputStream dst) throws IORuntimeException {
//         try {
//             return doEncode(source, dst, 0);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public long encodeTo(@Nonnull WritableByteChannel dst) throws IORuntimeException {
//         try {
//             return doEncode(source, dst, 0);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public int encodeTo(byte @Nonnull [] dst) throws IORuntimeException {
//         try {
//             return (int) doEncode(source, dst, 0);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public int encodeTo(byte @Nonnull [] dst, int off) throws IndexOutOfBoundsException, IORuntimeException {
//         IOChecker.checkOffLen(dst.length, off, dst.length - off);
//         try {
//             return (int) doEncode(source, dst, off);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public int encodeTo(@Nonnull ByteBuffer dst) throws IORuntimeException {
//         try {
//             return (int) doEncode(source, dst, 0);
//         } catch (IORuntimeException e) {
//             throw e;
//         } catch (Exception e) {
//             throw new IORuntimeException(e);
//         }
//     }
//
//     @Override
//     public String toString() {
//         return toString(JieChars.defaultCharset());
//     }
//
//     @Override
//     public InputStream asInputStream() {
//         // if (JieCollect.isEmpty(handlers)) {
//         //     return toInputStream(getSource());
//         // }
//         return new EncodingInputStream();
//     }
//
//     // private InputStream toInputStream(Object src) {
//     //     if (src instanceof InputStream) {
//     //         return (InputStream) src;
//     //     }
//     //     if (src instanceof byte[]) {
//     //         return IOKit.newInputStream((byte[]) src);
//     //     }
//     //     if (src instanceof ByteBuffer) {
//     //         return IOKit.newInputStream((ByteBuffer) src);
//     //     }
//     //     throw new IORuntimeException("The type of source is unsupported: " + src.getClass());
//     // }
//
//     private long doEncode(
//         @Nonnull Object src,
//         @Nullable Object dst,
//         int off
//     ) throws Exception {
//         if (readLimit == 0) {
//             return 0;
//         }
//         ByteReader reader;
//         if (src instanceof InputStream) {
//             reader = ByteReader.from((InputStream) src, readBlockSize);
//         } else {
//             reader = (ByteReader) src;
//         }
//         if (readLimit > 0) {
//             reader = reader.limit(readLimit);
//         }
//         if (JieCollect.isEmpty(handlers)) {
//             if (dst instanceof OutputStream) {
//                 return Math.max(reader.readTo((OutputStream) dst), 0);
//             } else if (dst instanceof byte[]) {
//                 return Math.max(reader.readTo((byte[]) dst, off, ((byte[]) dst).length - off), 0);
//             } else if (dst instanceof ByteBuffer) {
//                 return Math.max(reader.readTo((ByteBuffer) dst), 0);
//             } else if (dst == null) {
//                 return Math.max(reader.readTo(IOKit.nullOutputStream()), 0);
//             } else {
//                 throw new IORuntimeException("The type of destination is unsupported: " + dst.getClass() + ".");
//             }
//         }
//         long count = 0;
//         while (true) {
//             ByteSegment segment = reader.read(readBlockSize);
//             ByteBuffer buffer = segment.data();
//             boolean end = segment.end();
//             for (Handler handler : handlers) {
//                 buffer = handler.handle(buffer == null ? EMPTY_BUFFER : buffer, end);
//             }
//             if (buffer != null && buffer.hasRemaining()) {
//                 int writeSize = 0;
//                 if (dst instanceof OutputStream) {
//                     writeSize = BufferKit.readTo(buffer, (OutputStream) dst);
//                 } else if (dst instanceof byte[]) {
//                     writeSize = BufferKit.readTo(buffer, (byte[]) dst, off, ((byte[]) dst).length - off);
//                 } else if (dst instanceof ByteBuffer) {
//                     writeSize = BufferKit.readTo(buffer, (ByteBuffer) dst);
//                 } else if (dst == null) {
//                     writeSize = BufferKit.readTo(buffer, IOKit.nullOutputStream());
//                 } else {
//                     throw new IORuntimeException("The type of destination is unsupported: " + dst.getClass() + ".");
//                 }
//                 count += Math.max(writeSize, 0);
//             }
//             if (end) {
//                 break;
//             }
//         }
//         return count;
//     }
//
//     // private ByteReader toByteReader(Object src) {
//     //     if (src instanceof InputStream) {
//     //         return ByteReader.from((InputStream) src);
//     //     }
//     //     if (src instanceof byte[]) {
//     //         return ByteReader.from((byte[]) src);
//     //     }
//     //     if (src instanceof ByteBuffer) {
//     //         return ByteReader.from((ByteBuffer) src);
//     //     }
//     //     throw new IORuntimeException("The type of source is unsupported: " + src.getClass());
//     // }
//
//     // private Handler toOneEncoder(@Nullable List<Handler> encoders) {
//     //     if (JieCollect.isEmpty(encoders)) {
//     //         return Handler.emptyEncoder();
//     //     }
//     //     if (encoders.size() == 1) {
//     //         return encoders.get(0);
//     //     }
//     //     return (data, end) -> {
//     //         @Nullable ByteBuffer bytes = data;
//     //         for (Handler encoder : encoders) {
//     //             bytes = encoder.handle(bytes, end);
//     //             if (bytes == null) {
//     //                 break;
//     //             }
//     //         }
//     //         return bytes;
//     //     };
//     // }
//
//     private final class EncodingInputStream extends InputStream {
//
//         private @Nullable ByteSegment nextSeg = null;
//         private boolean closed = false;
//
//         private EncodingInputStream() {
//         }
//
//         private ByteSegment read0() throws IOException {
//             try {
//                 ByteSegment s0 = getSourceReader().read(readBlockSize);
//                 @Nullable ByteBuffer encoded = getEncoder().handle(s0.data(), s0.end());
//                 if (encoded == s0.data()) {
//                     return s0;
//                 }
//                 return ByteSegment.of(encoded, s0.end());
//             } catch (Exception e) {
//                 throw new IOException(e);
//             }
//         }
//
//         @Override
//         public int read() throws IOException {
//             checkClosed();
//             while (true) {
//                 if (nextSeg == null) {
//                     nextSeg = read0();
//                 }
//                 if (nextSeg == ByteSegment.empty(true)) {
//                     return -1;
//                 }
//                 if (nextSeg.data().hasRemaining()) {
//                     return nextSeg.data().get() & 0xff;
//                 }
//                 if (nextSeg.end()) {
//                     nextSeg = ByteSegment.empty(true);
//                     return -1;
//                 }
//                 nextSeg = null;
//             }
//         }
//
//         @Override
//         public int read(byte[] b) throws IOException {
//             return read(b, 0, b.length);
//         }
//
//         @Override
//         public int read(byte[] dst, int off, int len) throws IOException {
//             checkClosed();
//             checkOffsetLength(dst.length, off, len);
//             if (len <= 0) {
//                 return 0;
//             }
//             int pos = off;
//             int remaining = len;
//             while (remaining > 0) {
//                 if (nextSeg == ByteSegment.empty(true)) {
//                     return -1;
//                 }
//                 if (nextSeg == null) {
//                     nextSeg = read0();
//                 }
//                 if (nextSeg.data().hasRemaining()) {
//                     int readSize = Math.min(nextSeg.data().remaining(), remaining);
//                     nextSeg.data().get(dst, pos, readSize);
//                     pos += readSize;
//                     remaining -= readSize;
//                     continue;
//                 }
//                 if (nextSeg.end()) {
//                     nextSeg = ByteSegment.empty(true);
//                     break;
//                 } else {
//                     nextSeg = null;
//                 }
//             }
//             if (nextSeg.end() && pos == off) {
//                 return -1;
//             }
//             return pos - off;
//         }
//
//         @Override
//         public long skip(long n) throws IOException {
//             checkClosed();
//             if (n <= 0) {
//                 return 0;
//             }
//             long pos = 0;
//             long remaining = n;
//             while (remaining > 0) {
//                 if (nextSeg == ByteSegment.empty(true)) {
//                     return 0;
//                 }
//                 if (nextSeg == null) {
//                     nextSeg = read0();
//                 }
//                 if (nextSeg.data().hasRemaining()) {
//                     int readSize = (int) Math.min(nextSeg.data().remaining(), remaining);
//                     nextSeg.data().position(nextSeg.data().position() + readSize);
//                     pos += readSize;
//                     remaining -= readSize;
//                     continue;
//                 }
//                 if (nextSeg.end()) {
//                     nextSeg = ByteSegment.empty(true);
//                     break;
//                 } else {
//                     nextSeg = null;
//                 }
//             }
//             if (nextSeg.end() && pos == 0) {
//                 return 0;
//             }
//             return pos;
//         }
//
//         @Override
//         public int available() {
//             return nextSeg == null ? 0 : nextSeg.data().remaining();
//         }
//
//         @Override
//         public void close() throws IOException {
//             if (closed) {
//                 return;
//             }
//             if (source instanceof AutoCloseable) {
//                 try {
//                     ((AutoCloseable) source).close();
//                 } catch (IOException e) {
//                     throw e;
//                 } catch (Exception e) {
//                     throw new IOException(e);
//                 }
//             }
//             closed = true;
//         }
//
//         private void checkClosed() throws IOException {
//             if (closed) {
//                 throw new IOException("Stream closed.");
//             }
//         }
//     }
//
//     private static final class BufferMerger implements Function<Collection<ByteBuffer>, ByteBuffer> {
//
//         private static final BufferMerger SINGLETON = new BufferMerger();
//
//         @Override
//         public @Nullable ByteBuffer apply(Collection<ByteBuffer> byteBuffers) {
//             if (byteBuffers.isEmpty()) {
//                 return null;
//             }
//             int size = 0;
//             for (ByteBuffer byteBuffer : byteBuffers) {
//                 size += byteBuffer.remaining();
//             }
//             ByteBuffer result = ByteBuffer.allocate(size);
//             for (ByteBuffer byteBuffer : byteBuffers) {
//                 result.put(byteBuffer);
//             }
//             result.flip();
//             return result;
//         }
//     }
//
//     static final class FixedSizeEncoder implements Handler {
//
//         private final Handler encoder;
//         private final int size;
//
//         // Capacity is always the size.
//         private @Nullable ByteBuffer buffer;
//
//         FixedSizeEncoder(Handler encoder, int size) throws IllegalArgumentException {
//             this.encoder = encoder;
//             this.size = size;
//         }
//
//         @Override
//         public @Nullable ByteBuffer handle(ByteBuffer data, boolean end) throws Exception {
//             @Nullable Object result = null;
//             boolean encoded = false;
//
//             // clean buffer
//             if (buffer != null && buffer.position() > 0) {
//                 BufferKit.readTo(data, buffer);
//                 if (end && !data.hasRemaining()) {
//                     buffer.flip();
//                     return encoder.handle(buffer, true);
//                 }
//                 if (buffer.hasRemaining()) {
//                     return null;
//                 }
//                 buffer.flip();
//                 result = JieCoding.ifAdd(result, encoder.handle(buffer, false));
//                 encoded = true;
//                 buffer.clear();
//             }
//
//             // split
//             int pos = data.position();
//             int limit = data.limit();
//             while (limit - pos >= size) {
//                 pos += size;
//                 data.limit(pos);
//                 ByteBuffer slice = data.slice();
//                 data.position(pos);
//                 if (end && pos == limit) {
//                     result = JieCoding.ifAdd(result, encoder.handle(slice, true));
//                     return JieCoding.ifMerge(result, BufferMerger.SINGLETON);
//                 } else {
//                     result = JieCoding.ifAdd(result, encoder.handle(slice, false));
//                     encoded = true;
//                 }
//             }
//             data.limit(limit);
//
//             // buffering
//             if (data.hasRemaining()) {
//                 if (buffer == null) {
//                     buffer = ByteBuffer.allocate(size);
//                 }
//                 BufferKit.readTo(data, buffer);
//                 if (end) {
//                     buffer.flip();
//                     result = JieCoding.ifAdd(result, encoder.handle(buffer, true));
//                     encoded = true;
//                 }
//             }
//
//             @Nullable ByteBuffer ret = JieCoding.ifMerge(result, BufferMerger.SINGLETON);
//             if (end && !encoded) {
//                 return encoder.handle(JieBytes.emptyBuffer(), true);
//             }
//             return ret;
//         }
//     }
//
//     static final class RoundingEncoder implements Handler {
//
//         private final Handler encoder;
//         private final int size;
//
//         // Capacity is always the size.
//         private @Nullable ByteBuffer buffer;
//
//         RoundingEncoder(Handler encoder, int size) {
//             checkSize(size);
//             this.encoder = encoder;
//             this.size = size;
//         }
//
//         @Override
//         public @Nullable ByteBuffer handle(ByteBuffer data, boolean end) throws Exception {
//             @Nullable Object result = null;
//             boolean encoded = false;
//
//             // clean buffer
//             if (buffer != null && buffer.position() > 0) {
//                 BufferKit.readTo(data, buffer);
//                 if (end && !data.hasRemaining()) {
//                     buffer.flip();
//                     return encoder.handle(buffer, true);
//                 }
//                 if (buffer.hasRemaining()) {
//                     return null;
//                 }
//                 buffer.flip();
//                 result = JieCoding.ifAdd(result, encoder.handle(buffer, false));
//                 encoded = true;
//                 buffer.clear();
//             }
//
//             // rounding
//             int remaining = data.remaining();
//             int roundingSize = remaining / size * size;
//             if (roundingSize > 0) {
//                 int pos = data.position();
//                 pos += roundingSize;
//                 int limit = data.limit();
//                 data.limit(pos);
//                 ByteBuffer slice = data.slice();
//                 data.position(pos);
//                 data.limit(limit);
//                 if (end && pos == limit) {
//                     result = JieCoding.ifAdd(result, encoder.handle(slice, true));
//                     return JieCoding.ifMerge(result, BufferMerger.SINGLETON);
//                 } else {
//                     result = JieCoding.ifAdd(result, encoder.handle(slice, false));
//                     encoded = true;
//                 }
//             }
//
//             // buffering
//             if (data.hasRemaining()) {
//                 if (buffer == null) {
//                     buffer = ByteBuffer.allocate(size);
//                 }
//                 BufferKit.readTo(data, buffer);
//                 if (end) {
//                     buffer.flip();
//                     result = JieCoding.ifAdd(result, encoder.handle(buffer, true));
//                     encoded = true;
//                 }
//             }
//
//             @Nullable ByteBuffer ret = JieCoding.ifMerge(result, BufferMerger.SINGLETON);
//             if (end && !encoded) {
//                 return encoder.handle(JieBytes.emptyBuffer(), true);
//             }
//             return ret;
//         }
//     }
//
//     static final class BufferingEncoder implements Handler {
//
//         private final Handler encoder;
//         private byte @Nullable [] buffer = null;
//
//         BufferingEncoder(Handler encoder) {
//             this.encoder = encoder;
//         }
//
//         @Override
//         public @Nullable ByteBuffer handle(ByteBuffer data, boolean end) throws Exception {
//             ByteBuffer totalBuffer;
//             if (buffer != null) {
//                 ByteBuffer newBuffer = ByteBuffer.allocate(buffer.length + data.remaining());
//                 newBuffer.put(buffer);
//                 newBuffer.put(data);
//                 newBuffer.flip();
//                 totalBuffer = newBuffer;
//             } else {
//                 totalBuffer = data;
//             }
//             @Nullable ByteBuffer ret = encoder.handle(totalBuffer, end);
//             if (end) {
//                 buffer = null;
//                 return ret;
//             }
//             if (totalBuffer.hasRemaining()) {
//                 byte[] remainingBuffer = new byte[totalBuffer.remaining()];
//                 totalBuffer.get(remainingBuffer);
//                 buffer = remainingBuffer;
//             } else {
//                 buffer = null;
//             }
//             return ret;
//         }
//     }
//
//     static final class EmptyEncoder implements Handler {
//
//         static final EmptyEncoder SINGLETON = new EmptyEncoder();
//
//         @Override
//         public ByteBuffer handle(ByteBuffer data, boolean end) {
//             return data;
//         }
//     }
//
//     private static void checkSize(int size) {
//         if (size <= 0) {
//             throw new IllegalArgumentException("The size must > 0.");
//         }
//     }
// }
