package xyz.fslabo.common.base;

import xyz.fslabo.common.coll.JieColl;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;

/**
 * Builder to build a Random {@link Supplier} which can product random object for each calling of {@link Supplier#get()}.
 * <p>
 * The Random Supplier has pairs of {@code scores} and Child Suppliers. Each time a random object is generated, the
 * Random Supplier first randomly selects a Child Supplier based on the proportion of their scores, and then returns the
 * object generated by the selected Child Supplier.
 *
 * @param <T> type of random object to be built
 * @author fredsuvn
 */
public abstract class RandomBuilder<T> implements BaseBuilder<Supplier<T>, RandomBuilder<T>> {

    static <T> RandomBuilder<T> newInstance() {
        return new OfJdk8<>();
    }

    private int totalScore = 0;
    private Random random;
    private final List<Part<T>> parts = new LinkedList<>();

    RandomBuilder() {
        reset();
    }

    /**
     * Add a pair of score and value.
     * <p>
     * The Random Supplier has pairs of {@code scores} and Child Suppliers. Each time a random object is generated, the
     * Random Supplier first randomly selects a Child Supplier based on the proportion of their scores, and then returns
     * the object generated by the selected Child Supplier. In this method, the Child Supplier will always return the
     * specified value, it is equivalent to:
     * <pre>
     *     return score(score, () -> value);
     * </pre>
     *
     * @param score the score
     * @param value specified value
     * @return this builder
     * @see #score(int, Supplier)
     */
    public RandomBuilder<T> score(int score, T value) {
        return score(score, () -> value);
    }

    /**
     * Add a pair of score and child supplier.
     * <p>
     * The Random Supplier has pairs of {@code scores} and Child Suppliers. Each time a random object is generated, the
     * Random Supplier first randomly selects a Child Supplier based on the proportion of their scores, and then returns
     * the object generated by the selected Child Supplier.
     *
     * @param score    the score
     * @param supplier specified child value
     * @return this builder
     */
    public RandomBuilder<T> score(int score, Supplier<T> supplier) {
        parts.add(new Part<>(this.totalScore, this.totalScore + score, supplier));
        this.totalScore += score;
        return this;
    }

    /**
     * Specifies the underlying random to select the pairs of {@code scores} and Child Suppliers.
     * <p>
     * The Random Supplier has pairs of {@code scores} and Child Suppliers. Each time a random object is generated, the
     * Random Supplier first randomly selects a Child Supplier based on the proportion of their scores, and then returns
     * the object generated by the selected Child Supplier.
     *
     * @param random underlying random
     * @return this builder
     */
    public RandomBuilder<T> random(Random random) {
        this.random = random;
        return this;
    }

    /**
     * Builds a new Random {@link Supplier}.
     *
     * @return a new Random {@link Supplier}
     */
    @Override
    public Supplier<T> build() {
        if (JieColl.isEmpty(parts)) {
            throw new IllegalStateException("There is no score build.");
        }
        return new Impl<>(Jie.orDefault(random, new Random()), parts);
    }

    @Override
    public RandomBuilder<T> reset() {
        totalScore = 0;
        random = null;
        parts.clear();
        return this;
    }

    private static final class Impl<T> implements Supplier<T> {

        private final Random random;
        private final List<Part<T>> parts;

        private Impl(Random random, List<Part<T>> parts) {
            this.random = random;
            this.parts = JieColl.toList(parts);
        }

        @Override
        public T get() {
            int min = parts.get(0).from;
            int max = parts.get(parts.size() - 1).to;
            int next = random.nextInt(max - min) + min;
            for (Part<T> part : parts) {
                if (next >= part.from && next < part.to) {
                    return part.supplier.get();
                }
            }
            //never reach
            throw new IllegalStateException("Random part cannot be found.");
        }
    }

    private static class Part<T> {

        private final int from;
        private final int to;
        private final Supplier<T> supplier;

        private Part(int from, int to, Supplier<T> supplier) {
            this.from = from;
            this.to = to;
            this.supplier = supplier;
        }
    }

    private static final class OfJdk8<T> extends RandomBuilder<T> {
    }
}
